--- a/qml/Task.qml
+++ b/qml/Task.qml
@@ -28,6 +28,23 @@
     // so un-rotate them here to fix that.
     rotation: Plasmoid.configuration.reverseMode && Plasmoid.formFactor === PlasmaCore.Types.Vertical ? 180 : 0
 
+    // For pinned launchers on a horizontal multi-row panel, span all rows so
+    // the icon renders as a full-height square.
+    // implicitHeight intentionally stays at the per-row value so that TaskList's
+    // stripeCount calculation (which reads children[0].implicitHeight) is not
+    // affected. Layout.rowSpan and Layout.preferredHeight do the actual work.
+    readonly property bool isFullHeightLauncher: !inPopup && !tasksRoot.vertical
+                                                 && !tasksRoot.iconsOnly && model.IsLauncher
+
+    // Icon render size for full-height launchers: 80% of the panel height.
+    readonly property real launcherIconSize: Math.round(tasksRoot.height * 0.8)
+    // Button (cell) width is slightly narrower than the icon size to reduce the
+    // horizontal gap between adjacent launcher buttons. Subtracting half the
+    // frame's horizontal margins pulls the buttons closer together while keeping
+    // the icon itself at full launcherIconSize.
+    readonly property real launcherButtonWidth: Math.round(launcherIconSize
+        - TaskManagerApplet.LayoutMetrics.horizontalMargins() / 2)
+
     implicitHeight: inPopup
                     ? TaskManagerApplet.LayoutMetrics.preferredHeightInPopup()
                     : (tasksRoot.vertical
@@ -38,12 +55,45 @@
         ? Math.max(TaskManagerApplet.LayoutMetrics.preferredMinWidth(), Math.min(TaskManagerApplet.LayoutMetrics.preferredMaxWidth(), tasksRoot.width / Plasmoid.configuration.maxStripes))
         : 0
 
-    Layout.fillWidth: true
+    // Full-height launchers are fixed-width squares; regular tasks fill available width.
+    Layout.fillWidth: !isFullHeightLauncher
     Layout.fillHeight: !inPopup
+    // Add a left margin to tasks in the first task column to create a visual gap
+    // between the launcher group and the task bars. With TopToBottom flow the first
+    // task column contains the stripeCount items immediately after the launchers.
+    Layout.leftMargin: (!inPopup && !tasksRoot.vertical && !isFullHeightLauncher
+        && taskList.fullHeightLauncherCount > 0
+        && (index - taskList.fullHeightLauncherCount) < taskList.stripeCount
+        && (index - taskList.fullHeightLauncherCount) >= 0) ? 4 : 0
+    // Launchers span all rows and are given the full panel height explicitly.
+    // Span all actual stripes. Use stripeCount (not rows, which starts at 0)
+    // and fall back to maxStripes before stripeCount resolves.
+    Layout.rowSpan: isFullHeightLauncher
+        ? Math.max(1, taskList.stripeCount > 0 ? taskList.stripeCount : Plasmoid.configuration.maxStripes)
+        : 1
+    Layout.preferredWidth: isFullHeightLauncher ? launcherButtonWidth : -1
+    // Explicitly set the preferred height for both launchers and tasks so Qt's
+    // GridLayout row-height solver distributes rows evenly.
+    // Without this, Qt gives the row containing the single task more than its
+    // fair share when a rowSpan=2 launcher is the only other height constraint.
+    Layout.preferredHeight: inPopup ? -1
+        : (isFullHeightLauncher
+            ? tasksRoot.height
+            : Math.max(TaskManagerApplet.LayoutMetrics.preferredMinHeight(),
+                       tasksRoot.height / Math.max(1, taskList.stripeCount)))
     Layout.maximumWidth: tasksRoot.vertical
         ? -1
-        : ((model.IsLauncher && !tasksRoot.iconsOnly) ? tasksRoot.height / taskList.rows : TaskManagerApplet.LayoutMetrics.preferredMaxWidth())
-    Layout.maximumHeight: tasksRoot.vertical ? TaskManagerApplet.LayoutMetrics.preferredMaxHeight() : -1
+        : (isFullHeightLauncher ? launcherButtonWidth : TaskManagerApplet.LayoutMetrics.preferredMaxWidth())
+    // Cap task height to one stripe so Qt's GridLayout cannot over-expand the
+    // task into the empty second row when there is only one window task open.
+    // Use taskList.rows (set by Qt after layout) with maxStripes as fallback
+    // to avoid division by zero before rows is resolved.
+    Layout.maximumHeight: (tasksRoot.vertical || isFullHeightLauncher)
+        ? TaskManagerApplet.LayoutMetrics.preferredMaxHeight()
+        : Math.max(TaskManagerApplet.LayoutMetrics.preferredMinHeight(),
+                   tasksRoot.height / Math.max(1, taskList.rows > 0
+                       ? taskList.rows
+                       : Plasmoid.configuration.maxStripes))
 
     required property var model
     required property int index
@@ -460,8 +510,11 @@
         anchors {
             fill: parent
 
-            topMargin: (!task.tasksRoot.vertical && taskList.rows > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
-            bottomMargin: (!task.tasksRoot.vertical && taskList.rows > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
+            // Don't add top/bottom icon margin for launchers â€” they span all rows
+            // and should fill the full panel height without inset.
+            topMargin: (!task.tasksRoot.vertical && taskList.rows > 1 && !task.model.IsLauncher) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
+            bottomMargin: (!task.tasksRoot.vertical && taskList.rows > 1 && !task.model.IsLauncher) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
+
             leftMargin: ((task.inPopup || task.tasksRoot.vertical) && taskList.columns > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
             rightMargin: ((task.inPopup || task.tasksRoot.vertical) && taskList.columns > 1) ? TaskManagerApplet.LayoutMetrics.iconMargin : 0
         }
@@ -584,7 +637,11 @@
 
                 PropertyChanges {
                     iconBox.anchors.leftMargin: 0
-                    iconBox.width: Math.min(task.parent.minimumWidth, tasksRoot.height)
+                    // For full-height launchers, size the icon to 80% of the panel
+                    // height rather than filling the full panel height.
+                    iconBox.width: (task.isFullHeightLauncher
+                        ? task.launcherIconSize
+                        : Math.min(task.parent.minimumWidth, tasksRoot.height))
                         - iconBox.adjustMargin(true, task.width, taskFrame.margins.left)
                         - iconBox.adjustMargin(true, task.width, taskFrame.margins.right)
                 }
--- a/qml/TaskList.qml
+++ b/qml/TaskList.qml
@@ -30,31 +30,77 @@
         .filter(item => item.visible && item.width > 0)
         .reduce((minimumWidth, item) => Math.min(minimumWidth, item.width), Infinity)
 
+    // Count how many children are full-height launchers (rowSpan = all rows).
+    // These each occupy exactly 1 column regardless of stripeCount.
+    readonly property int fullHeightLauncherCount: {
+        let n = 0;
+        for (let i = 0; i < children.length; ++i) {
+            if (children[i].isFullHeightLauncher === true) {
+                ++n;
+            }
+        }
+        return n;
+    }
+
     readonly property int stripeCount: {
         if (Plasmoid.configuration.maxStripes === 1) {
             return 1;
         }
+        if (children.length === 0) {
+            return Plasmoid.configuration.maxStripes;
+        }
+
+        // Use the first non-full-height-launcher child's implicitHeight/Width for
+        // the stripeSizeLimit calculation, so that full-height launchers (which
+        // have a larger preferredHeight) don't incorrectly reduce stripeCount.
+        // Find a Task child that is not a full-height launcher to use as the
+        // reference for implicitHeight. Skip non-Task children (e.g. Repeater).
+        let referenceChild = null;
+        for (let i = 0; i < children.length; ++i) {
+            const child = children[i];
+            if (child.hasOwnProperty("isFullHeightLauncher") && !child.isFullHeightLauncher) {
+                referenceChild = child;
+                break;
+            }
+        }
+        // Fall back to any Task child if all are full-height launchers.
+        if (!referenceChild) {
+            for (let i = 0; i < children.length; ++i) {
+                if (children[i].hasOwnProperty("isFullHeightLauncher")) {
+                    referenceChild = children[i];
+                    break;
+                }
+            }
+        }
+        if (!referenceChild) {
+            referenceChild = children[0];
+        }
 
         // The maximum number of stripes allowed by the applet's size
         const stripeSizeLimit = vertical
-            ? Math.floor(parent.width / children[0].implicitWidth)
-            : Math.floor(parent.height / children[0].implicitHeight)
+            ? Math.floor(parent.width / referenceChild.implicitWidth)
+            : Math.floor(parent.height / referenceChild.implicitHeight)
         const maxStripes = Math.min(Plasmoid.configuration.maxStripes, stripeSizeLimit)
 
         if (Plasmoid.configuration.forceStripes) {
             return maxStripes;
         }
 
+        const nonLaunchers = count - fullHeightLauncherCount;
+
         // The number of tasks that will fill a "stripe" before starting the next one
         const maxTasksPerStripe = vertical
             ? Math.ceil(parent.height / TaskManagerApplet.LayoutMetrics.preferredMinHeight())
             : Math.ceil(parent.width / TaskManagerApplet.LayoutMetrics.preferredMinWidth())
 
-        return Math.min(Math.ceil(count / maxTasksPerStripe), maxStripes)
+        return Math.min(Math.ceil(nonLaunchers / maxTasksPerStripe), maxStripes)
     }
 
     readonly property int orthogonalCount: {
-        return Math.ceil(count / stripeCount);
+        // Full-height launchers each occupy 1 column; remaining items share
+        // columns in the normal stripeCount rows.
+        const nonLauncherCount = count - fullHeightLauncherCount;
+        return fullHeightLauncherCount + Math.ceil(nonLauncherCount / stripeCount);
     }
 
     rows: vertical ? orthogonalCount : stripeCount
--- a/qml/main.qml
+++ b/qml/main.qml
@@ -443,6 +443,18 @@
                 readonly property real heightOccupation: taskRepeater.count / rows
 
                 Layout.maximumWidth: {
+                    // For mixed launcher/task columns, compute the actual maximum
+                    // content width directly rather than using the widthOccupation
+                    // heuristic (which assumes all items have the same maxWidth).
+                    const launcherCols = taskList.fullHeightLauncherCount;
+                    const taskCols = Math.max(0, columns - launcherCols);
+                    if (!tasks.vertical && launcherCols > 0 && taskCols > 0) {
+                        const launcherWidth = Math.round(tasks.height * 0.8) // launcherIconSize
+                            - Math.round(TaskManagerApplet.LayoutMetrics.horizontalMargins() / 2); // launcherButtonWidth adjustment
+                        return launcherCols * launcherWidth
+                             + taskCols * TaskManagerApplet.LayoutMetrics.preferredMaxWidth();
+                    }
+                    // Upstream formula for all other cases (vertical, no launchers, etc.)
                     const totalMaxWidth = children.reduce((accumulator, child) => {
                             if (!isFinite(child.Layout.maximumWidth)) {
                                 return accumulator;
--- a/main.xml
+++ b/main.xml
@@ -8,7 +8,7 @@
   <group name="General">
     <entry name="showOnlyCurrentScreen" type="Bool">
       <label>Whether to show only window tasks that are on the same screen as the widget.</label>
-      <default>false</default>
+      <default>true</default>
     </entry>
     <entry name="showOnlyCurrentDesktop" type="Bool">
       <label>Whether to only show tasks that are on the current virtual desktop.</label>
@@ -28,7 +28,7 @@
     </entry>
     <entry name="groupingStrategy" type="Enum">
       <label>How tasks are grouped: 0 = Do Not Group, 1 = By Program Name</label>
-      <default>1</default>
+      <default>0</default>
     </entry>
     <entry name="groupedTaskVisualization" type="Enum">
       <label>What happens when clicking on a grouped task: 0 = cycle through grouped tasks, 1 = try to show tooltips, 2 = try to show present Windows effect, 3 = show textual list (AKA group dialog)</label>
@@ -52,7 +52,7 @@
     </entry>
     <entry name="sortingStrategy" type="Int">
       <label>Values from TaskManager::TasksModel::SortMode</label>
-      <default>1</default>
+      <default>0</default>
     </entry>
     <entry name="separateLaunchers" type="Bool">
       <label>Whether launcher tasks are sorted separately at the left side of the widget or can be mixed with other tasks.</label>
@@ -60,16 +60,16 @@
     </entry>
     <entry name="hideLauncherOnStart" type="Bool">
       <label>Whether launcher tasks should be hidden when their application is launched.</label>
-      <default>true</default>
+      <default>false</default>
     </entry>
     <entry name="maxStripes" type="Int">
       <label>The maximum number of rows (in a horizontal-orientation containment, i.e. panel) or columns (in a vertical-orientation containment) to layout task buttons in.</label>
-      <default>1</default>
+      <default>2</default>
       <min>1</min>
     </entry>
     <entry name="forceStripes" type="Bool">
       <label>Whether to try and always layout task buttons in as many rows/columns as set via maxStripes.</label>
-      <default>false</default>
+      <default>true</default>
     </entry>
     <entry name="showToolTips" type="Bool">
       <label>Whether to show tooltips when hovering task buttons.</label>
